零、遇到的难点问题
	一、springboot整合mybatis遇到的那些坑
		
	二、Java重构代码复用的问题（继承，resultType，<sql>标签）

	三、配置数据库加解密
	
壹、准备好的问题：
	一、url请求的过程
	
	二、mybatis常见面试题
	
贰、领域模型中的4个模式：
	1、失血模式；很纯粹的domain object，只有getter/setter方法
	2、贫血模式；基于失血模式，会添加一些只与当前对象状态相关的方法，不会依赖于比如上层service或下层dao，能够内部实现单元测试，不必依赖系统框架（比如调用其他依赖或服务）
	3、充血模式；基于贫血模式，更多的逻辑处理放了进来，甚至省去了业务处理层，这种就会出现复杂度高，耦合度高，不易于维护；
	4、胀血模式；基于充血模式，省去了service层，直接实现dao层。	
	
	领域模型是领域内的概念类或现实世界中对象的可视化表示，又称为概念模型或分析对象模型，它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。
	贫血模型是指使用的领域对象中只有setter和getter方法（POJO），所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。有人将我们这里说的贫血模型进一步划分成失血模型（领域对象完全没有业务逻辑）和贫血模型（领域对象有少量的业务逻辑），
	我们这里就不对此加以区分了。充血模型将大多数业务逻辑和持久化放在领域对象中，业务逻辑（业务门面）只是完成对业务逻辑的封装、事务和权限等的处理。下面两张图分别展示了贫血模型和充血模型的分层架构。
	https://blog.csdn.net/troubleshooter/article/details/78479984

叁、为什么要Java重构？重构的是哪些内容？
	数据库访问层采用mybatis框架。
	
	优点：
	相比于rails用的orm框架，mybatis可以更加方便地做到细粒度的sql优化，性能更加出色，也更加灵活。（Mybatis：半自动的ORM框架(懂数据库的人 才能操作) 要自己写sql）
	mybatis作为一个持久性框架，而不是orm框架，对开发人员更加易学，直观，不容易犯orm框架的诸如n+1的问题。
	使用spring作为工程框架，可以非常容易的实现数据库读写分离。
	社区更加活跃， 工具支持更加广泛，可以很方便的使用社区或者公司开发的工具链进行开发，部署以及监控等工作。
	第三方依赖更加丰富，后续增加其他模块更加方便和灵活。
	运行效率高。容易招人。
	
	缺点：
	代码量大，rails的orm框架几行代码搞定的功能，java中可能要上百行。
	gitlab关联表多，字段多，对开发人员的sql能力有要求，并且对mybatis映射功能设计有要求，不然容易引起xml文件爆照增长。
	mybatis直接写sql，强依赖于数据库，会使数据库移植苦难，如果以后要切mysql，需要改绝大部分的sql语句，工作量大，易出错。
	用java重写的其他优点：

	
	工作量：
	使用java重构gitlab的代码，由于在rails和mybatis在持久化层上的区别（参考“在领域模型实现方面，tail和spring boot有什么差别？”），导致在用java重构业务逻辑时，有时候不能用gitlab的原有逻辑去直接重写，而需要适配java的框架和最佳实践，导致工作量并不比用java直接实现该功能小，再加上测试用例的补充和保障，在工作量上，用java重构，应该比用rails写同样的功能要多。

	下一步困难：
	测试用例的补充：当前在线测试用例不足，当前很多接口只有一个测试用例，无法做到大部分的功能场景覆盖，重构容易出错，上线后容易出现bug增加的情况。
	用java重写功能开发工作量大。
	java代码层面还没有一个详细的规划和架构，贸然重构和添加代码，容易让各模块之间有很强的耦合，以及产生大量的冗余代码，导致后续优化变得困难。

	@@@@@什么是n+1问题？
		User和Post是一对多的关系，也就是User是Post的外键。现在系统里面有十个用户，每个用户写了一篇文章，也就是十篇文章。
		接下来我们有一个需求，展示一个文章列表页，列表页上展示的信息包括：文章标题，文章作者名称。就这两个字段，也不需要分页。
		我们要查询出这样的数据要怎么做呢。在ORM的世界中，我们直观的做法是这样:每次循环都要查一下user表，也就是说，如果我第一次查询是10条记录，那么最终我需要执行的查询语句就是10 + 1 = 11条语句。如果我第一次查询出来的是N条记录，那么最终需要执行的sql语句就是N+1次。
		这就是N+1的问题。但是如果懂SQL的话，就知道，其实这就是一个简单的JOIN语句。一条语句就能查出所有的数据，搞什么N+1.



肆、springboot 和 mybatis的学习和思考和优化建议
	一、学习
		1、如何配置映射，resultMap和resultType的区别：
			MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，resultType是直接表示返回类型的(对应着我们的model对象中的实体)，而resultMap则是对外部ResultMap的引用(提前定义了db和model之间的隐射key-->value关系)，但是resultType跟resultMap不能同时存在。
			在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。
			①当提供的返回类型属性是resultType时，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，只是当提供的返回类型属性是resultType的时候，MyBatis对自动的给把对应的值赋给resultType所指定对象的属性。
			②当提供的返回类型是resultMap时，因为Map不能很好表示领域模型，就需要自己再进一步的把它转化为对应的对象，这常常在复杂查询中很有作用。
	
		2、注意代码复用，<sql>标签的使用
	
	
伍、数据库	
	一、长连接短链接概念
		* 短连接
		连接-》数据传输-》关闭连接；
		* 长连接
		连接-》数据传输-》保持连接-》数据传输-》保持连接-》…………-》关闭连接；

		这就要求长连接在没有数据通信时，定时发送数据包，以维持连接状态，短连接在没有数据传输时直接关闭就行了。
	二、数据库读写分离（和负载均衡）
		$$读写分离的好处：
			1.增加冗余

			2.增加了机器的处理能力

			3.对于读操作为主的应用，使用读写分离是最好的场景，因为可以确保写的服务器压力更小，而读又可以接受点时间上的延迟。
		 
		$$读写分离提高性能之原因：
			1.物理服务器增加，负荷增加

			2.主从只负责各自的写和读，极大程度的缓解X锁和S锁争用

			3.从库可配置myisam引擎，提升查询性能以及节约系统开销

			4.从库同步主库的数据和主库直接写还是有区别的，通过主库发送来的binlog恢复数据，但是，最重要区别在于主库向从库发送binlog是异步的，从库恢复数据也是异步的

			5.读写分离适用与读远大于写的场景，如果只有一台服务器，当select很多时，update和delete会被这些select访问中的数据堵塞，等待select结束，并发性能不高。 对于写和读比例相近的应用，应该部署双主相互复制

			6.可以在从库启动是增加一些参数来提高其读的性能，例如--skip-innodb、--skip-bdb、--low-priority-updates以及--delay-key-write=ALL。当然这些设置也是需要根据具体业务需求来定得，不一定能用上

			7..分摊读取。假如我们有1主3从，不考虑上述1中提到的从库单方面设置，假设现在1 分钟内有10条写入，150条读取。那么，1主3从相当于共计40条写入，而读取总数没变，因此平均下来每台服务器承担了10条写入和50条读取（主库不 承担读取操作）。因此，虽然写入没变，但是读取大大分摊了，提高了系统性能。另外，当读取被分摊后，又间接提高了写入的性能。所以，总体性能提高了，说白 了就是拿机器和带宽换性能。MySQL官方文档中有相关演算公式：官方文档 见6.9FAQ之“MySQL复制能够何时和多大程度提高系统性能”

			8.MySQL复制另外一大功能是增加冗余，提高可用性，当一台数据库服务器宕机后能通过调整另外一台从库来以最快的速度恢复服务，因此不能光看性能，也就是说1主1从也是可以的。：
	
	三、为什么要使用数据库连接池 、好处是什么
		1. 基本原理：在内部对象池中，维护一定数量的数据库连接，并对外暴露数据库连接的获取和返回方法。
			如外部使用者可通过getConnection方法获取数据库连接，使用完毕后再通过releaseConnection方法将连接返回，注意此时的连接并没有关闭，而是由连接池管理器回收，并为下一次使用做好准备。

		2.作用

		   ①资源重用 (连接复用)

			  由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，增进了系统环境的平稳性（减少内存碎片以级数据库临时进程、线程的数量）

		   ②更快的系统响应速度

			  数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池内备用。此时连接池的初始化操作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。

		   ③新的资源分配手段

			  对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接技术。

		   ④统一的连接管理，避免数据库连接泄露

			 在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用的连接，从而避免了常规数据库连接操作中可能出现的资源泄露
		
		3、 PostgreSQL是一个多进程结构的系统，由master主进程fork出一系列子进程，每个连接都有一个独立的进程与之交互，所以如果应用有几千个以上的连接连数据库，可能会开始有性能下降（或者有内存浪费的问题，发生OOM）。
			PostgreSQL进程架构：
			- postgres server process  是所有进程的父进程
			- backend process 每一个客户端的连接都有一个后端进程存在
		
	四、数据库的切分
		1、垂直切分：垂直切分是根据业务来拆分数据库，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。
			垂直切分解决了什么问题：
				垂直切分可以降低单节点数据库的负载。原来所有数据表都放在一个数据库节点上，无疑所有的读写请求也都发到这个MySQL上面，所以数据库的负载太高。如果把一个节点的数据库拆分成多个MySQL数据库，这样就可以有效的降低每个MySQL数据库的负载。

			垂直切分不能解决什么问题：
				垂直切分不能解决的是缩表，比如说商品表无论划分给哪个数据库节点，商品表的记录还是那么多，不管你把数据库垂直拆分的有多细致，每个数据表里面的数据量是没有变化的。MySQL单表记录超过2000万，读写性能会下降的很快，因此说垂直切分并不能起到缩表的效果。

		2、水平切分：水平切分是按照某个字段的某种规则，把数据切分到多张数据表。一张数据表化整为零，拆分成多张数据表，这样就可以起到缩表的效果了。
			水平切分的好处：
			水平切分可以把数据切分到多张数据表，可以起到缩表的作用。
			但是也不是所有的数据表都要做水平切分。数据量较大的数据表才需要做数据切分，比如说电商系统中的，用户表、商品表、产品表、地址表、订单表等等。有些数据表就不需要切分，因为数据量不多，比如说品牌表、供货商表、仓库表，这些都是不需要切分的。

			水平切分的缺点：
			不同数据表的切分规则并不一致，要根据实际业务来确定。所以我们在选择数据库中间件产品的时候，就要选择切分规则丰富的产品。常见的数据库中间件有：MyCat、Atlas（阿里）、ProxySQL等等。有些人觉得MyCat是Java语言开发的，就怀疑MyCat运行效率。其实数据库中间件的作用相当于SQL语句的路由器。你家路由器硬件配置不怎么高，但是不影响你享用百兆宽带。MyCat也是一个道理，它仅仅是起到SQL语句转发的作用，并不会实际执行SQL语句。我推荐使用MyCat最主要的原因是它自带了非常多的数据切分规则，我们可以按照主键求模切分数据，可以按照主键范围切分数据，还可以按照日期切分数据等等。因此说，为了满足业务的需要，MyCat目前来说算是非常不错的中间件产品。
			水平切分的另一个缺点就是扩容比较麻烦，日积月累，分片迟早有不够用的时候。这时候不是首先选择增加新的集群分片。因为一个MySQL分片，需要4~8个MySQL节点（最小规模），增加一个分片的投入成本是很高的。所以正确的做法是做冷热数据分离，定期对分片中的数据归档。把过期的业务数据，从分片中转移到归档库。目前来说数据压缩比最高的MySQL引擎是TokuDB，而且带着事物的写入速度是InnoDB引擎的6-14倍。用TokuDB作为归档数据库最适合不过。

	
	
	五、放在真实场景里：
		优化目标：解决热点仓库在IO上性能瓶颈，提供多读能力，提高仓库的出口带宽。
		关键点：
		数据一致性：保证从只读仓库下载到最新的代码
		负载均衡：从仓适度分担主仓库下载IO压力，
		副本扩缩容：合理水平扩展从仓量，从仓同步主仓会占用主仓IO资源，大量的主从同步会对主仓造成同步对压力，需要合理分配从仓数量； 在项目上升级需要分配更多的副本，在项目维护期需要减少副本
		同步策略：在非常活跃的项目中，主仓的Refs变化很快，但分支、Tag相对变化比较慢，MR的Head变化也比较慢，MR的Merge变化比较快，需要合理安排同步和判断主从一致性，减少从仓同步

	
	
	
